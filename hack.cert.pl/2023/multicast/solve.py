 #!/usr/bin/python3.4
   # Written by Anirudh Anand (lucif3r) : email - anirudh@anirudhanand.com   
   # This program will help to decrypt cipher text to plain text if you have
   # more than 1 cipher text encrypted with same Modulus (N) but different
   # exponents. We use extended Euclideangm Algorithm to achieve this.
   
__author__ = 'lucif3r'
   
import gmpy2
   

class RSAModuli:
    def __init__(self):
           self.a = 0
           self.b = 0
           self.m = 0
           self.i = 0
    def gcd(self, num1, num2):
           """
           This function os used to find the GCD of 2 numbers.
           :param num1:
           :param num2:
           :return:
           """
           if num1 < num2:
               num1, num2 = num2, num1
           while num2 != 0:
               num1, num2 = num2, num1 % num2
           return num1
    def extended_euclidean(self, e1, e2):
           """
           The value a is the modular multiplicative inverse of e1 and e2.
           b is calculated from the eqn: (e1*a) + (e2*b) = gcd(e1, e2)
           :param e1: exponent 1
           :param e2: exponent 2
           """
           self.a = gmpy2.invert(e1, e2)
           self.b = (float(self.gcd(e1, e2)-(self.a*e1)))/float(e2)
    def modular_inverse(self, c1, c2, N):
           """
           i is the modular multiplicative inverse of c2 and N.
           i^-b is equal to c2^b. So if the value of b is -ve, we
           have to find out i and then do i^-b.
           Final plain text is given by m = (c1^a) * (i^-b) %N
           :param c1: cipher text 1
           :param c2: cipher text 2
           :param N: Modulus
           """
           i = gmpy2.invert(c2, N)
           mx = pow(c1, self.a, N)
           my = pow(i, int(-self.b), N)
           self.m= mx * my % N
    def print_value(self):
           print("Plain Text: ", self.m)
   
   
def main():
       c = RSAModuli()
       N  = 22853547217398845404758538162976312008117086507201563768578187702405373669038552766649424224736630167553269428342329722510531033416673544533956234449922612958267231240312003631979119102406992957430182319626592965892604298170528064832345262965018269924252848084587185430591498740063101833034331362994356741049000571232064678613699861006210328776107655448729220485734797531631214460577394634637546128436204783069238118721510647005497538248817496430070398464678420087855627753304313097212644058129034061766157503541019007728062140306972463022819448845884555029819772262614724322542630283243695701149640513342334749777903
       c1 = 20429464901695090564370754806615977973302971871608342268506259174147192993151277337616814417296801075217152633393226606732015425943428125739465485449507399545445847504439713384248836689208767562142623070231354642211300595145416493173379727021766328292208698967376624851343222629098043788002679171029732957535744599278633217261376537355499929045059482425465991634530876220597593430340293387518607408617531556489324454820402059224001477384246596026368041283426946767245650120802420009232957325153049932422376155910084707638842141120399474406015371172539482019632062332103057615394694644346009027605021019746722301172607
       c2 = 8036644697895676357067206384100119323409315272010583362224911768365591326654078012037338583302688618907433145568954536946780476910315102816799209892503252505513907106379916873026249258774096217841473948746246021700389072992313583041572553082904308979654185841652303647459902357193672160996604554727679595348574265172675762303927642386587105415613565764411196127912203842455872558866143173550395993672849954144977264388470404537494957673592265409761962251824403539200992224517908947205273332024619857905909132817247249337622963777899835385455928875155630416525280139874573420448957344805316154162817593385814653126344
       e1 = 2420826451
       e2 = 3011981543
       c.extended_euclidean(e1, e2)
       c.modular_inverse(c1, c2, N)
       c.print_value()
    
if __name__ == '__main__':
        main()